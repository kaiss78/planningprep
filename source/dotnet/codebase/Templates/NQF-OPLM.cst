<%@ CodeTemplate Language="C#" TargetLanguage="C#" Inherits="CodeSmith.BaseTemplates.SqlCodeTemplate" Description="Generates a C# class for use with NHibnate" %>
<%@ Property Name="SourceTable" Type="SchemaExplorer.TableSchema" Category="Context" Description="Table that the mapping file is based on" %>
<%@ Property Name="NamespaceOfEntityClass" Type="System.String" Default="OPLM.Common.Entity" Category="Object" Description="The class namespace that the mapping file should use" %>
<%@ Property Name="NamespaceOfDAOClass" Type="System.String" Default="OPLM.DAL" Category="Object" Description="The class namespace that the mapping file should use" %>
<%@ Property Name="Assembly" Type="System.String" Default="MyApp.MyAssembly" Category="Object" Description="The assembly that the class will be used in" %>
<%@ Property Name="RemoveTablePrefix" Type="System.String" Default="OPLM" Category="Object" Description="The prefix to remove from table names" %>
<%@ Property Name="ForceId" Type="System.Boolean" Default="true" Category="Object" Description="Force Id for identity column" %>
<%@ Assembly Name="SchemaExplorer" %>
<%@ Assembly Name="CodeSmith.BaseTemplates" %>
<%@ Assembly Name="System.Data" %>

<%@ Import Namespace="SchemaExplorer" %>
<%@ Import Namespace="CodeSmith.BaseTemplates" %>
<%@ Import Namespace="System.Data" %>
<%@ Import Namespace="System.Text" %>
<%@ Import Namespace="System.Text.RegularExpressions" %>

<%-- 
This template demonstrates using properties defined in external assemblies.

CodeSmith is 100% extensible.  A property can be any .NET type that has designer support.
This includes all of the standard .NET data types and most other standard .NET types as well.

You can also create your own custom property types or you can use one any of the custom types
included in CodeSmith.  This template uses the included SchemaExplorer.TableSchema type and is
defined in the SchemaExplorer assembly.  This type provides access to nearly all possible schema
information about a particular database table.
--%>

<%
// this template requires a primary key on the source table
if (!SourceTable.HasPrimaryKey) throw new ApplicationException("SourceTable does not contain a primary key. \nThis Template Requires a Primary Key in " + SourceTable.FullName + " table to Generate C# Classes and Stored Procedures ");

%>

#region DTO Class Generator

#region History

/* --------------------------------------------------------------------------------
 * Client Name: NQF
 * Project Name: OPLM
 * Module: OPLM.Common
 * Name: <%=GetClassName(this.SourceTable.FullName)%>.cs
 * Purpose: Entity class for <%=GetClassName(this.SourceTable.FullName)%>
 *                   
 * Author: MHR
 * Language: C# SDK version 2.0
 * --------------------------------------------------------------------------------
 * Change History:
 * version: 1.0    MHR  <%=DateTime.Today.ToString("MM/dd/yyyy") %>
 * Description: Initial Development
 * -------------------------------------------------------------------------------- */

#endregion

#region References

using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using Pantheon.Core.DB;
using System.Data;
using OPLM.Common.Entity;

#endregion

#region Class

namespace <%=NamespaceOfEntityClass%>
{
	public class <%= GetClassName(this.SourceTable.FullName)%> : BaseEntity
	{
		#region Instance creation

		/// <summary>
        /// Creates the new Entity object.
        /// </summary>
        /// <returns></returns>
        public static <%= GetClassName(this.SourceTable.FullName)%> Instance
        {
			get{ return new <%= GetClassName(this.SourceTable.FullName)%>(); }
        }

        /// <summary>
        /// Creates an <%= GetClassName(this.SourceTable.FullName)%> object from DataReader
        /// </summary>
        /// <param name="reader">The reader.</param>
        /// <returns></returns>
        public static <%= GetClassName(this.SourceTable.FullName)%> CreateFromDataReader(IDataReader reader)
        {
            <%= GetClassName(this.SourceTable.FullName)%> <%=CamelCase(GetClassName(this.SourceTable.FullName))%> = Instance;
			<% foreach (ColumnSchema column in this.SourceTable.Columns) { 
				if(column.IsPrimaryKeyMember){%>
			<%=CamelCase(GetClassName(this.SourceTable.FullName))%>.ID = <%=GetReaderString(column)%>;		
				<%}
				else{%>
			<%=CamelCase(GetClassName(this.SourceTable.FullName))%>.<%=PropertyName(column)%> = <%=GetReaderString(column)%>;
			<% }
			} %>
			return <%=CamelCase(GetClassName(this.SourceTable.FullName))%>;
        }

        #endregion
		
		#region Properties
		
		<% foreach (ColumnSchema column in this.SourceTable.Columns) { 
			if(!column.IsPrimaryKeyMember){%>
			private <%= MemberType(column) %> <%= MemberName(column) %>;
		<% } 
		}%>
		
		<% foreach (ColumnSchema column in this.SourceTable.Columns) { 
			if(!column.IsPrimaryKeyMember){
			%>
			/// <summary>
			/// Gets or sets the <%= PropertyName(column) %>
			/// </summary>
			public <%= MemberType(column)%> <%= PropertyName(column) %>
			{
				get { return <%= MemberName(column) %>; }			
				set { <%= MemberName(column) %> = value; }		
			}
		<% } 
		}%>
	
		#endregion
	}
}

#endregion

#endregion DTO Class Generator



#region Stored Procedure to Save Object to Database 

SET QUOTED_IDENTIFIER OFF;
SET ANSI_NULLS ON;
SET NOCOUNT ON;
GO

IF EXISTS (	SELECT *
			FROM INFORMATION_SCHEMA.ROUTINES
			WHERE ROUTINE_NAME = '<%=GetProcedureName(SourceTable, 1)%>'
				AND ROUTINE_TYPE = 'PROCEDURE' )
BEGIN
	PRINT 'Dropping stored procedure <%=GetProcedureName(SourceTable, 1)%>.';
	DROP PROCEDURE <%=GetProcedureName(SourceTable, 1)%>;
END

GO

/*
 * ====================================================================
 * BASIC INFORMATION
 * ====================================================================
 *
 * --Client Name			: NQF
 * --Project Name			: New Website Implemenation
 * --Procedure name			: <%=GetProcedureName(SourceTable, 1)%>
 * --Purpose/Function		: Saves a <%= GetClassName(this.SourceTable.FullName)%> object
 * --Author					: MHR
 * --Start Date(MM/DD/YY)	: <%=DateTime.Today.ToString("MM/dd/yyyy") %>
 *
 * ====================================================================
 * IMPLEMENTATION LOGIC
 * ====================================================================
 *
 * --
 *
 * ====================================================================
 * PERFORMANCE (To be filled up by developer,with "Yes" values)
 * ====================================================================
 *
 * --TSQL reviewed				: No
 * --Indexing done properly		: No
 * --Index fragmentation checked: No
 * --Comment					: No comment
 *
 * ===================================================================
 * REVIEW (To be filled up by reviewer,with "Yes" values)
 * ===================================================================
 *
 * --Reviewed by				: 
 * --Review	date				: 
 * --TSQL reviewed				: No
 * --Indexing done properly		: No
 * --Index fragmentation checked: No
 * --Comment					: No comment
 *
 * ===================================================================
 * CHANGE HISTORY
 * ===================================================================
 * Date				Name	Comments
 * <%=DateTime.Today.ToString("MM/dd/yyyy") %>		MHR		Initial Development				
 * ===================================================================*/

-------------------------------------------------------------------------------
--	METADATA AND OTHER MESSAGES ABOVE.
--	BEGIN CREATE STATEMENTS.
-------------------------------------------------------------------------------

CREATE PROCEDURE dbo.<%= GetProcedureName(SourceTable, 1)%>(
<%=GenerateParameterList(SourceTable)%><%=GenerateIndent(1) %>, @GeneratedID <%=GetSqlDataType(SourceTable.PrimaryKey.MemberColumns[0])%> OUTPUT
)
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	-- If Exists then Update the Existing Record
	IF EXISTS(SELECT * FROM <%= this.SourceTable.FullName%> WHERE <%=GetPrimaryKeyFieldName(SourceTable) %> = @<%=GetPrimaryKeyFieldName(SourceTable)%>)
	BEGIN
		-- Update Existing <%= GetClassName(this.SourceTable.FullName)%> Information
<%=GenerateUpdatableStatement(SourceTable)%>		
	END
	ELSE
	BEGIN
		-- New Record, So insert it into the <%= this.SourceTable.FullName%>
<%=GenerateInsertStatement(SourceTable)%>		
	END
END

GO

-------------------------------------------------------------------------------
--	END OF CREATE STATEMENTS.
--	METADATA AND SUCCESS/ERROR MESSAGES BELOW.
-------------------------------------------------------------------------------
IF EXISTS (	SELECT *
			FROM INFORMATION_SCHEMA.ROUTINES
			WHERE ROUTINE_NAME = '<%= GetProcedureName(SourceTable, 1)%>'
				AND ROUTINE_TYPE = 'PROCEDURE' )
BEGIN
	PRINT 'Stored procedure <%= GetProcedureName(SourceTable, 1)%> created successfully.';	
END
ELSE
BEGIN
	PRINT 'ERROR: Failed to create stored procedure <%= GetProcedureName(SourceTable, 1)%>.';
END
GO


#endregion Stored Procedure to Save Object to Database 



#region  Stored Procedure to Get Object From Database

SET QUOTED_IDENTIFIER OFF;
SET ANSI_NULLS ON;
SET NOCOUNT ON;
GO

IF EXISTS (	SELECT *
			FROM INFORMATION_SCHEMA.ROUTINES
			WHERE ROUTINE_NAME = '<%=GetProcedureName(SourceTable, 2)%>'
				AND ROUTINE_TYPE = 'PROCEDURE' )
BEGIN
	PRINT 'Dropping stored procedure <%=GetProcedureName(SourceTable, 2)%>.';
	DROP PROCEDURE <%=GetProcedureName(SourceTable, 2)%>;
END

GO

/*
 * ====================================================================
 * BASIC INFORMATION
 * ====================================================================
 *
 * --Client Name			: NQF
 * --Project Name			: New Website Implemenation
 * --Procedure name			: <%=GetProcedureName(SourceTable, 2)%>
 * --Purpose/Function		: Saves a <%= GetClassName(this.SourceTable.FullName)%> object
 * --Author					: MHR
 * --Start Date(MM/DD/YY)	: <%=DateTime.Today.ToString("MM/dd/yyyy") %>
 *
 * ====================================================================
 * IMPLEMENTATION LOGIC
 * ====================================================================
 *
 * --
 *
 * ====================================================================
 * PERFORMANCE (To be filled up by developer,with "Yes" values)
 * ====================================================================
 *
 * --TSQL reviewed				: No
 * --Indexing done properly		: No
 * --Index fragmentation checked: No
 * --Comment					: No comment
 *
 * ===================================================================
 * REVIEW (To be filled up by reviewer,with "Yes" values)
 * ===================================================================
 *
 * --Reviewed by				: 
 * --Review	date				: 
 * --TSQL reviewed				: No
 * --Indexing done properly		: No
 * --Index fragmentation checked: No
 * --Comment					: No comment
 *
 * ===================================================================
 * CHANGE HISTORY
 * ===================================================================
 * Date				Name	Comments
 * <%=DateTime.Today.ToString("MM/dd/yyyy") %>		MHR		Initial Development				
 * ===================================================================*/

-------------------------------------------------------------------------------
--	METADATA AND OTHER MESSAGES ABOVE.
--	BEGIN CREATE STATEMENTS.
-------------------------------------------------------------------------------

CREATE PROCEDURE dbo.<%= GetProcedureName(SourceTable, 2)%>(
	@<%=GetPrimaryKeyFieldName(SourceTable)%> <%= GetSqlDataType(SourceTable.PrimaryKey.MemberColumns[0])%>
)
AS
BEGIN
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
<%=GenerateSelectStatement(SourceTable)%>			
END

GO

-------------------------------------------------------------------------------
--	END OF CREATE STATEMENTS.
--	METADATA AND SUCCESS/ERROR MESSAGES BELOW.
-------------------------------------------------------------------------------
IF EXISTS (	SELECT *
			FROM INFORMATION_SCHEMA.ROUTINES
			WHERE ROUTINE_NAME = '<%= GetProcedureName(SourceTable, 2)%>'
				AND ROUTINE_TYPE = 'PROCEDURE' )
BEGIN
	PRINT 'Stored procedure <%= GetProcedureName(SourceTable, 2)%> created successfully.';	
END
ELSE
BEGIN
	PRINT 'ERROR: Failed to create stored procedure <%= GetProcedureName(SourceTable, 2)%>.';
END
GO


#endregion Stored Procedure to Get Object From Database 



#region DAO (Collection) Class Generator

#region History

/* --------------------------------------------------------------------------------
 * Client Name: NQF
 * Project Name: OPLM
 * Module: OPLM.Common
 * Name: <%=GetClassName(this.SourceTable.FullName)%>DAO.cs
 * Purpose: DAO class for <%=GetClassName(this.SourceTable.FullName)%>
 *                   
 * Author: MHR
 * Language: C# SDK version 2.0
 * --------------------------------------------------------------------------------
 * Change History:
 * version: 1.0    MHR  <%=DateTime.Today.ToString("MM/dd/yyyy") %>
 * Description: Initial Development
 * -------------------------------------------------------------------------------- */

#endregion

#region References

using System;
using System.Collections.Generic;
using System.Text;
using System.Data.Common;
using Microsoft.Practices.EnterpriseLibrary.Data;
using System.Data;
using System.Data.SqlClient;
using OPLM.Common.Entity;
using <%=NamespaceOfEntityClass%>;
using OPLM.Common.Util;

#endregion

#region Class

namespace <%=NamespaceOfDAOClass%>
{

	public class <%= GetClassName(this.SourceTable.FullName)%>DAO : DataAccess,IDAO 
	{
		
		#region IDAO Members

		/// <summary>
		///	Saves <%= GetClassName(this.SourceTable.FullName)%> object to the Database
		/// </summary>	
        public void Save(OPLM.Common.Entity.BaseEntity entity)
        {
            string SP = "dbo.Save<%= GetClassName(this.SourceTable.FullName)%>";
			<%= GetClassName(this.SourceTable.FullName)%> <%=CamelCase(GetClassName(this.SourceTable.FullName))%> = entity as <%= GetClassName(this.SourceTable.FullName)%>;
			try
			{
				using (DbCommand dbCommand = Database.GetStoredProcCommand(SP))
				{
					//Database.AddInParameter(dbCommand, "@ID", DbType.Int32, <%=CamelCase(SourceTable.Name)%>.ID);					
					<% 					
					foreach (ColumnSchema column in this.SourceTable.Columns) 
					{					
						//if(column.Name != "ID")
					%>							
					Database.AddInParameter(dbCommand, "@<%=column.Name%>", <%=GetParameterType(column)%>, <%=CamelCase(GetClassName(this.SourceTable.FullName))%>.<%= PropertyName(column) %>);
					<%					
					} %>	
					///The Output Parameter
					Database.AddOutParameter(dbCommand, "@GeneratedID", <%=GetParameterType(SourceTable.PrimaryKey.MemberColumns[0])%>, <%=SourceTable.PrimaryKey.MemberColumns[0].Size%>);                    
					Database.ExecuteNonQuery(dbCommand);
					///Read the Output Parameter Value                    
					<%=MemberType(SourceTable.PrimaryKey.MemberColumns[0])%> newID = dbCommand.Parameters["@GeneratedID"].Value == System.DBNull.Value ? -1 : (<%=MemberType(SourceTable.PrimaryKey.MemberColumns[0])%>)dbCommand.Parameters["@GeneratedID"].Value;
	
					if (<%=CamelCase(GetClassName(this.SourceTable.FullName))%>.ID == 0)
						<%=CamelCase(GetClassName(this.SourceTable.FullName))%>.ID = newID;
				}
			}
			catch (Exception ex)
			{
				throw ex;
			}
        }

        public void Delete(OPLM.Common.Entity.BaseEntity entity)
        {
            //throw new NotImplementedException();
        }

        public void Update(OPLM.Common.Entity.BaseEntity entity)
        {
            //throw new NotImplementedException();
        }

        #endregion
		
		#region Constructor

        public <%= GetClassName(this.SourceTable.FullName)%>DAO()
        {
            
        }
		
		#endregion
		
		#region Instance
		
		/// <summary>
		///	Creates a New Object of the  <%= GetClassName(this.SourceTable.FullName)%>DAO Class
		/// </summary>
		public static <%= GetClassName(this.SourceTable.FullName)%>DAO Instance
		{
			get
			{
				return new <%= GetClassName(this.SourceTable.FullName)%>DAO();
			}
		}
		
		#endregion
		
		#region Methods		
		
		/// <summary>
		///	Gets <%= GetClassName(this.SourceTable.FullName)%> object by <%=SourceTable.PrimaryKey.MemberColumns[0].Name%>
		/// </summary>
		/// <param name="id"><%=SourceTable.PrimaryKey.MemberColumns[0].Name%> of the <%= GetClassName(this.SourceTable.FullName)%></param>
		public <%= GetClassName(this.SourceTable.FullName)%> Get<%= GetClassName(this.SourceTable.FullName)%>ByID(<%=CSharpType(SourceTable.PrimaryKey.MemberColumns[0])%> id)
		{
			string SP = "dbo.<%= GetProcedureName(SourceTable, 2)%>";
			IDataReader reader = null;
			try
			{
				using (DbCommand dbCommand = Database.GetStoredProcCommand(SP))
				{
					Database.AddInParameter(dbCommand, "@<%=GetPrimaryKeyFieldName(SourceTable)%>", <%=GetParameterType(SourceTable.PrimaryKey.MemberColumns[0])%>, id);					
					reader = Database.ExecuteReader(dbCommand);
					if (reader.Read())
					{
						return <%= GetClassName(this.SourceTable.FullName)%>.CreateFromDataReader(reader);
					}
				}
			}
			catch(Exception ex)
			{
				throw ex;
			}
			finally
			{
				if(reader != null && !reader.IsClosed)
					reader.Close();
			}
			return null;
		}
		
		#endregion
	}
}

#endregion

#endregion DAO (Collection) Class Generator


<script runat="template">

public string GetPrimaryKeyFieldName(TableSchema table)
{
	return table.PrimaryKey.MemberColumns[0].Name;
}

public string GenerateParameterList(TableSchema table)
{
	StringBuilder sb = new StringBuilder(20);	
	int i = 0;
	foreach (ColumnSchema column in this.SourceTable.Columns) 
	{ 	
		if(i == 0)
			sb.AppendFormat("{0}@{1} {2}{3}", GenerateIndent(1), column.Name, GetSqlDataType(column), Environment.NewLine);					
		else
			sb.AppendFormat("{0}, @{1} {2}{3}", GenerateIndent(1), column.Name, GetSqlDataType(column), Environment.NewLine);							
		i++;	
	}
	return sb.ToString();
}

public string GenerateUpdatableStatement(TableSchema table)
{
	StringBuilder sb = new StringBuilder(20);	
	sb.AppendFormat("{0}UPDATE {1} SET{2}", GenerateIndent(2), table.FullName, Environment.NewLine);
	int i = 0;
	foreach (ColumnSchema column in this.SourceTable.Columns) 
	{ 	
		if(!column.IsPrimaryKeyMember)
		{
			if(i == 0)
				sb.AppendFormat("{2}{0} = @{0}{1}", column.Name, Environment.NewLine, GenerateIndent(3));
				//sb.AppendFormat("@{0} {1}{3}", column.Name, GetSqlDataType(column), Environment.NewLine);					
			else
				sb.AppendFormat("{2}, {0} = @{0}{1}", column.Name, Environment.NewLine, GenerateIndent(3));
				//sb.AppendFormat("{0}, @{1} {2}{3}", GenerateIndent(1), column.Name, GetSqlDataType(column), Environment.NewLine);							
			i++;	
		}
	}
	sb.AppendFormat("{0}WHERE {1} = @{1};{2}", GenerateIndent(2), GetPrimaryKeyFieldName(table), Environment.NewLine);
	sb.AppendFormat("{0}SET @GeneratedID = @{1};", GenerateIndent(2), GetPrimaryKeyFieldName(table));
	return sb.ToString();	
}

public string GenerateInsertStatement(TableSchema table)
{
	StringBuilder sb = new StringBuilder(20);	
	StringBuilder values = new StringBuilder(20);	
	sb.AppendFormat("{0}INSERT INTO {1} (", GenerateIndent(2), table.FullName);
	values.AppendFormat("{0}VALUES(", GenerateIndent(2));
	int columnCount = table.Columns.Count - 1;
	int i = 0;
	foreach (ColumnSchema column in this.SourceTable.Columns) 
	{ 	
		if(!column.IsPrimaryKeyMember)
		{
			if(i == 0)
			{
				sb.AppendFormat("{0}{1}", column.Name, Environment.NewLine);
				values.AppendFormat("@{0}{1}", column.Name, Environment.NewLine);				
			}
			else
			{
				if(columnCount == (i + 1))
				{
					sb.AppendFormat("{0}, {1}", GenerateIndent(3), column.Name);				
					values.AppendFormat("{0}, @{1}", GenerateIndent(3), column.Name);
				}
				else
				{
					sb.AppendFormat("{0}, {1}{2}", GenerateIndent(3), column.Name, Environment.NewLine);				
					values.AppendFormat("{0}, @{1}{2}", GenerateIndent(3), column.Name, Environment.NewLine);
				}
			}
			i++;	
		}
	}
	sb.AppendFormat("){0}", Environment.NewLine);		
	values.AppendFormat(");{0}", Environment.NewLine);
	values.AppendFormat("{0}SET @GeneratedID = SCOPE_IDENTITY();", GenerateIndent(2));
	sb.Append(values.ToString());
	return sb.ToString();	
}

public string GenerateSelectStatement(TableSchema table)
{
	StringBuilder sb = new StringBuilder(20);
	sb.AppendFormat("{0}SELECT ", GenerateIndent(1));
	int i = 0;
	foreach (ColumnSchema column in this.SourceTable.Columns) 
	{ 			
		if(i == 0)
			sb.AppendFormat("{0}{1}", column.Name, Environment.NewLine);			
		else
			sb.AppendFormat("{0}, {1}{2}", GenerateIndent(2), column.Name, Environment.NewLine);			
		i++;		
	}
	sb.AppendFormat("{0}FROM {1}{2}",  GenerateIndent(1), table.FullName, Environment.NewLine);
	sb.AppendFormat("{0}WHERE {1} = @{1};", GenerateIndent(1), GetPrimaryKeyFieldName(table), Environment.NewLine);	
	return sb.ToString();
}
	
public string GetProcedureName(TableSchema table, int procedureType)
{	
	string sourceTableName = table.FullName;
	if(sourceTableName.IndexOf(".") > -1)	
		sourceTableName = sourceTableName.Substring(sourceTableName.LastIndexOf(".") + 1);	
	if(procedureType == 1)		
		return String.Format("Save_{0}", sourceTableName);	
	else if(procedureType == 2)	
		return String.Format("Get_{0}_By{1}", sourceTableName, GetPrimaryKeyFieldName(table));	
	return String.Empty;
}

public string GenerateIndent(int indentLevel)
{
	StringBuilder sb = new StringBuilder(10);
    for (int i = 0; i < indentLevel; i++)
	{
		sb.Append('\t');
	}
	return sb.ToString();
}
</script>


<script runat="template">
///NHibernate Functions

private Regex cleanRegEx = new Regex(@"\s+|_|-|\.", RegexOptions.Compiled);
private Regex cleanID = new Regex(@"(_ID|_id|_Id|\.ID|\.id|\.Id|ID|Id)", RegexOptions.Compiled);

public string CleanName(string name)
{
	return cleanRegEx.Replace(name, "");
}

public string CamelCase(string name)
{
	string output = CleanName(name);
	return char.ToLower(output[0]) + output.Substring(1);
}

public string PascalCase(string name)
{
	string output = CleanName(name);
	return char.ToUpper(output[0]) + output.Substring(1);
}

public string MakePlural(string name)
{
	Regex plural1 = new Regex("(?<keep>[^aeiou])y$");
	Regex plural2 = new Regex("(?<keep>[aeiou]y)$");
	Regex plural3 = new Regex("(?<keep>[sxzh])$");
	Regex plural4 = new Regex("(?<keep>[^sxzhy])$");

	if(plural1.IsMatch(name))
		return plural1.Replace(name, "${keep}ies");
	else if(plural2.IsMatch(name))
		return plural2.Replace(name, "${keep}s");
	else if(plural3.IsMatch(name))
		return plural3.Replace(name, "${keep}es");
	else if(plural4.IsMatch(name))
		return plural4.Replace(name, "${keep}s");

	return name;
}

public string MakeSingle(string name)
{
	Regex plural1 = new Regex("(?<keep>[^aeiou])ies$");
	Regex plural2 = new Regex("(?<keep>[aeiou]y)s$");
	Regex plural3 = new Regex("(?<keep>[sxzh])es$");
	Regex plural4 = new Regex("(?<keep>[^sxzhyu])s$");

	if(plural1.IsMatch(name))
		return plural1.Replace(name, "${keep}y");
	else if(plural2.IsMatch(name))
		return plural2.Replace(name, "${keep}");
	else if(plural3.IsMatch(name))
		return plural3.Replace(name, "${keep}");
	else if(plural4.IsMatch(name))
		return plural4.Replace(name, "${keep}");

	return name;
}

public bool IsManyToManyTable(TableSchema table)
{
	if (table.Columns.Count == 2 && table.PrimaryKey != null && table.PrimaryKey.MemberColumns.Count == 2 && table.ForeignKeys.Count == 2)
//	if (table.Columns.Count >= 2 && table.PrimaryKey != null && table.PrimaryKey.MemberColumns.Count == 2 && table.ForeignKeys.Count >= 2)
		return true;
	else
		return false;
}

public bool IsOneToOneTable(TableKeySchema primaryKey)
{
	if (primaryKey.ForeignKeyMemberColumns[0].IsPrimaryKeyMember)
	{
		// Check if the current table is the primary key with one-to-one mappings to several tables.
		// If so, generate polymorphic classes using joined sub-classes & corresponding C# classes.
		int count = 0;
		foreach(TableKeySchema pk in SourceTable.PrimaryKeys)
		{
			// check if other end of the link is the primary key for the table (if count > 1 then it may
			// be a composite primary key and most likely a many-to-many link table which can be ignored)
			if (pk.ForeignKeyMemberColumns[0].IsPrimaryKeyMember && pk.ForeignKeyTable.PrimaryKey.MemberColumns.Count == 1)
				count++;
		}
		if (count > 1)
			return false;

		return true;
	}
	return false;
}

public bool IsSubClassTable(TableKeySchema primaryKey)
{
	if (primaryKey.ForeignKeyMemberColumns[0].IsPrimaryKeyMember)
	{
		// Check if the current table is the primary key with one-to-one mappings to several tables.
		// If so, generate polymorphic classes using joined sub-classes & corresponding C# classes.
		int count = 0;
		foreach(TableKeySchema pk in SourceTable.PrimaryKeys)
		{
			// check if other end of the link is the primary key for the table (if count > 1 then it may
			// be a composite primary key and most likely a many-to-many link table which can be ignored)
			if (pk.ForeignKeyMemberColumns[0].IsPrimaryKeyMember && pk.ForeignKeyTable.PrimaryKey.MemberColumns.Count == 1)
				count++;
		}
		if (count > 1)
			return true;

		return false;
	}
	return false;
}

public string CSharpType(ColumnSchema column)
{
	if (column.Name.EndsWith("TypeCode")) return column.Name;

	switch (column.DataType)
	{
		case DbType.AnsiString: return "string";
		case DbType.AnsiStringFixedLength: return "string";
		case DbType.Binary: return "byte[]";
		case DbType.Boolean: return "bool";
		case DbType.Byte: return "byte";
		case DbType.Currency: return "decimal";
		case DbType.Date: return "DateTime";
		case DbType.DateTime: return "DateTime";
		case DbType.Decimal: return "decimal";
		case DbType.Double: return "double";
		case DbType.Guid: return "Guid";
		case DbType.Int16: return "short";
		case DbType.Int32: return "int";
		case DbType.Int64: return "long";
		case DbType.Object: return "object";
		case DbType.SByte: return "sbyte";
		case DbType.Single: return "float";
		case DbType.String: return "string";
		case DbType.StringFixedLength: return "string";
		case DbType.Time: return "TimeSpan";
		case DbType.UInt16: return "ushort";
		case DbType.UInt32: return "uint";
		case DbType.UInt64: return "ulong";
		case DbType.VarNumeric: return "decimal";
		default:
		{
			return "__UNKNOWN__" + column.NativeType;
		}
	}
}

public string NHibernateType(ColumnSchema column)
{
	if (column.Name.EndsWith("TypeCode")) return column.Name;

	switch (column.DataType)
	{
		case DbType.AnsiString: return "String";
		case DbType.AnsiStringFixedLength: return "String";
		case DbType.Binary: return "Byte[]";
		case DbType.Boolean: return "Boolean";
		case DbType.Byte: return "Byte";
		case DbType.Currency: return "Decimal";
		case DbType.Date: return "DateTime";
		case DbType.DateTime: return "DateTime";
		case DbType.Decimal: return "Decimal";
		case DbType.Double: return "Double";
		case DbType.Guid: return "Guid";
		case DbType.Int16: return "Int16";
		case DbType.Int32: return "Int32";
		case DbType.Int64: return "Int64";
		case DbType.Object: return "BinaryBlob";
		case DbType.SByte: return "Byte";
		case DbType.Single: return "Single";
		case DbType.String: return "String";
		case DbType.StringFixedLength: return "String";
		case DbType.Time: return "DateTime";
		case DbType.UInt16: return "Int16";
		case DbType.UInt32: return "Int32";
		case DbType.UInt64: return "Int64";
		case DbType.VarNumeric: return "Decimal";
		default:
		{
			return "__UNKNOWN__" + column.NativeType;
		}
	}
}

private Regex sqlCharacters = new Regex(@"[\s|~|-|!|{|%|}|\^|'|&|.|\(|\\|\)|`]", RegexOptions.Compiled);
private Regex sqlReserved = new Regex(@"^(ADD|EXCEPT|PERCENT|ALL|EXEC|PLAN|ALTER|EXECUTE|PRECISION|AND|EXISTS|PRIMARY|ANY|EXIT|PRINT|AS|FETCH|PROC|ASC|FILE|PROCEDURE|AUTHORIZATION|FILLFACTOR|PUBLIC|BACKUP|FOR|RAISERROR|BEGIN|FOREIGN|READ|BETWEEN|FREETEXT|READTEXT|BREAK|FREETEXTTABLE|RECONFIGURE|BROWSE|FROM|REFERENCES|BULK|FULL|REPLICATION|BY|FUNCTION|RESTORE|CASCADE|GOTO|RESTRICT|CASE|GRANT|RETURN|CHECK|GROUP|REVOKE|CHECKPOINT|HAVING|RIGHT|CLOSE|HOLDLOCK|ROLLBACK|CLUSTERED|IDENTITY|ROWCOUNT|COALESCE|IDENTITY_INSERT|ROWGUIDCOL|COLLATE|IDENTITYCOL|RULE|COLUMN|IF|SAVE|COMMIT|IN|SCHEMA|COMPUTE|INDEX|SELECT|CONSTRAINT|INNER|SESSION_USER|CONTAINS|INSERT|SET|CONTAINSTABLE|INTERSECT|SETUSER|CONTINUE|INTO|SHUTDOWN|CONVERT|IS|SOME|CREATE|JOIN|STATISTICS|CROSS|KEY|SYSTEM_USER|CURRENT|KILL|TABLE|CURRENT_DATE|LEFT|TEXTSIZE|CURRENT_TIME|LIKE|THEN|CURRENT_TIMESTAMP|LINENO|TO|CURRENT_USER|LOAD|TOP|CURSOR|NATIONAL||TRAN|DATABASE|NOCHECK|TRANSACTION|DBCC|NONCLUSTERED|TRIGGER|DEALLOCATE|NOT|TRUNCATE|DECLARE|NULL|TSEQUAL|DEFAULT|NULLIF|UNION|DELETE|OF|UNIQUE|DENY|OFF|UPDATE|DESC|OFFSETS|UPDATETEXT|DISK|ON|USE|DISTINCT|OPEN|USER|DISTRIBUTED|OPENDATASOURCE|VALUES|DOUBLE|OPENQUERY|VARYING|DROP|OPENROWSET|VIEW|DUMMY|OPENXML|WAITFOR|DUMP|OPTION|WHEN|ELSE|OR|WHERE|END|ORDER|WHILE|ERRLVL|OUTER|WITH|ESCAPE|OVER|WRITETEXT)$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
private Regex sqlFuture = new Regex(@"^(ABSOLUTE|FOUND|PRESERVE|ACTION|FREE|PRIOR|ADMIN|GENERAL|PRIVILEGES|AFTER|GET|READS|AGGREGATE|GLOBAL|REAL|ALIAS|GO|RECURSIVE|ALLOCATE|GROUPING|REF|ARE|HOST|REFERENCING|ARRAY|HOUR|RELATIVE|ASSERTION|IGNORE|RESULT|AT|IMMEDIATE|RETURNS|BEFORE|INDICATOR|ROLE|BINARY|INITIALIZE|ROLLUP|BIT|INITIALLY|ROUTINE|BLOB|INOUT|ROW|BOOLEAN|INPUT|ROWS|BOTH|INT|SAVEPOINT|BREADTH|INTEGER|SCROLL|CALL|INTERVAL|SCOPE|CASCADED|ISOLATION|SEARCH|CAST|ITERATE|SECOND|CATALOG|LANGUAGE|SECTION|CHAR|LARGE|SEQUENCE|CHARACTER|LAST|SESSION|CLASS|LATERAL|SETS|CLOB|LEADING|SIZE|COLLATION|LESS|SMALLINT|COMPLETION|LEVEL|SPACE|CONNECT|LIMIT|SPECIFIC|CONNECTION|LOCAL|SPECIFICTYPE|CONSTRAINTS|LOCALTIME|SQL|CONSTRUCTOR|LOCALTIMESTAMP|SQLEXCEPTION|CORRESPONDING|LOCATOR|SQLSTATE|CUBE|MAP|SQLWARNING|CURRENT_PATH|MATCH|START|CURRENT_ROLE|MINUTE|STATE|CYCLE|MODIFIES|STATEMENT|DATA|MODIFY|STATIC|DATE|MODULE|STRUCTURE|DAY|MONTH|TEMPORARY|DEC|NAMES|TERMINATE|DECIMAL|NATURAL|THAN|DEFERRABLE|NCHAR|TIME|DEFERRED|NCLOB|TIMESTAMP|DEPTH|NEW|TIMEZONE_HOUR|DEREF|NEXT|TIMEZONE_MINUTE|DESCRIBE|NO|TRAILING|DESCRIPTOR|NONE|TRANSLATION|DESTROY|NUMERIC|TREAT|DESTRUCTOR|OBJECT|TRUE|DETERMINISTIC|OLD|UNDER|DICTIONARY|ONLY|UNKNOWN|DIAGNOSTICS|OPERATION|UNNEST|DISCONNECT|ORDINALITY|USAGE|DOMAIN|OUT|USING|DYNAMIC|OUTPUT|VALUE|EACH|PAD|VARCHAR|END-EXEC|PARAMETER|VARIABLE|EQUALS|PARAMETERS|WHENEVER|EVERY|PARTIAL|WITHOUT|EXCEPTION|PATH|WORK|EXTERNAL|POSTFIX|WRITE|FALSE|PREFIX|YEAR|FIRST|PREORDER|ZONE|FLOAT|PREPARE)$", RegexOptions.Compiled | RegexOptions.IgnoreCase);

public string SqlIdentifier(string sqlIdentifier)
{
	if (sqlCharacters.IsMatch(sqlIdentifier) || sqlReserved.IsMatch(sqlIdentifier) || sqlFuture.IsMatch(sqlIdentifier))
		return String.Format("`{0}`", sqlIdentifier);
	else
		return sqlIdentifier;
}

public string TableClass(TableSchema table)
{
	string className = table.Name;
	if (className.StartsWith(RemoveTablePrefix))
		className = className.Substring(RemoveTablePrefix.Length);
	return String.Format("{0}", MakeSingle(PascalCase(className)));
}

public string TableClassFull(TableSchema table)
{
	//return String.Format("{0}.{1}, {2}", Namespace, TableClass(table), Assembly);
	return String.Format("{0}.{1}, {2}", NamespaceOfEntityClass, TableClass(table), Assembly);
	
}

public string TableCollection(TableSchema table)
{
	string className = table.Name;
	if (className.StartsWith(RemoveTablePrefix))
		className = className.Substring(RemoveTablePrefix.Length);
	return String.Format("{0}", MakePlural(PascalCase(className)));
}
public string ClassName(TableSchema table)
{
	return TableClass(table);
}
public string ClassNameAtt(TableSchema table)
{
	return String.Format(" name=\"{0}\"", TableClassFull(table));
}
public string ClassTable(TableSchema table)
{
	return table.Name;
}
public string ClassTableAtt(TableSchema table)
{
	return String.Format(" table=\"{0}\"", SqlIdentifier(table.Name));
}

public string IdMemberName(TableSchema table)
{
	if (ForceId)
		return "_id";
	else
		return MemberName(table.PrimaryKey.MemberColumns[0]);
}
public string IdName(TableSchema table)
{
	if (ForceId)
		return "Id";
	else
		return PropertyName(table.PrimaryKey.MemberColumns[0]);
}
public string IdNameAtt(TableSchema table)
{
	return String.Format(" name=\"{0}\"", IdName(table));
}
public string IdMemberType(TableSchema table)
{
	return MemberType(table.PrimaryKey.MemberColumns[0]);
}
public string IdType(TableSchema table)
{
	return PropertyType(table.PrimaryKey.MemberColumns[0]);
}
public string IdTypeAtt(TableSchema table)
{
	return String.Format(" type=\"{0}\"", PropertyType(table.PrimaryKey.MemberColumns[0]));
}
public string IdUnsavedValueAtt(TableSchema table)
{
	ColumnSchema column = table.PrimaryKey.MemberColumns[0];
	if (column.Size == 0)
		return String.Format(" unsaved-value=\"{0}\"", 0);
	else
		return String.Format(" unsaved-value=\"{0}\"", "null");
}

public string PropertyName(ColumnSchema column)
{
	return PascalCase(column.Name);
}
public string MemberName(ColumnSchema column)
{
	return "_" + CamelCase(column.Name);
}
public string ParameterName(ColumnSchema column)
{
	return CamelCase(column.Name);
}
public string PropertyNameAtt(ColumnSchema column)
{
	return String.Format(" name=\"{0}\"", PropertyName(column));
}
public string PropertyType(ColumnSchema column)
{
	return NHibernateType(column);
}
public string MemberType(ColumnSchema column)
{
	return CSharpType(column);
}

public string PropertyTypeAtt(ColumnSchema column)
{
	return String.Format(" type=\"{0}\"", PropertyType(column));
}

public string ColumnName(ColumnSchema column)
{
	return column.Name;
}
public string ColumnNameAtt(ColumnSchema column)
{
	return String.Format(" name=\"{0}\"", SqlIdentifier(ColumnName(column)));
}
public string ColumnLength(ColumnSchema column)
{
	if (column.Size > 0)
		return column.Size.ToString();
	else
		return String.Empty;
}
public string ColumnLengthAtt(ColumnSchema column)
{
	if (column.Size > 0)
		return String.Format(" length=\"{0}\"", column.Size);
	else
		return String.Empty;
}
public string ColumnSqlTypeAtt(ColumnSchema column)
{
	return String.Format(" sql-type=\"{0}\"", column.NativeType);
}
public string ColumnNotNullAtt(ColumnSchema column)
{
	return String.Format(" not-null=\"{0}\"", (!column.AllowDBNull).ToString().ToLower());
}
public string ColumnUniqueAtt(ColumnSchema column)
{
	if (column.IsUnique)
		return String.Format(" unique=\"{0}\"", column.IsUnique.ToString().ToLower());
	else
		return String.Empty;
}
public string ColumnIndexAtt(TableSchema table, ColumnSchema column)
{
	foreach(IndexSchema index in table.Indexes)
	{
		if (index.MemberColumns.Contains(column))
		{
			return String.Format(" index=\"{0}\"", index.Name);
		}
	}
	return String.Empty;
}

public string ManyToOneName(TableKeySchema foreignKey)
{
	string className = TableClass(foreignKey.PrimaryKeyTable);

	string thiskey = foreignKey.ForeignKeyMemberColumns[0].Name;
	string primarykey = foreignKey.PrimaryKeyMemberColumns[0].Name;

	string differentiator = thiskey.Replace(primarykey, "").Replace("ID","");
	
	string returnName = (differentiator == "" ? className : differentiator);

	return returnName;
}
public string ManyToOneMemberName(TableKeySchema foreignKey)
{
	return "_" + CamelCase(ManyToOneName(foreignKey));
}
public string ManyToOneParameterName(TableKeySchema foreignKey)
{
	return CamelCase(ManyToOneName(foreignKey));
}
public string ManyToOneNameAtt(TableKeySchema foreignKey)
{
	return String.Format(" name=\"{0}\"", ManyToOneName(foreignKey));
}
public string ManyToOneClass(TableKeySchema foreignKey)
{
	string className = TableClass(foreignKey.PrimaryKeyTable);

	return className;
}
public string ManyToOneClassAtt(TableKeySchema foreignKey)
{
	string className = TableClassFull(foreignKey.PrimaryKeyTable);

	return String.Format(" class=\"{0}\"", className);
}

public string OneToOneName(TableKeySchema primaryKey)
{
	string className = TableClass(primaryKey.ForeignKeyTable);

	string thiskey = primaryKey.PrimaryKeyMemberColumns[0].Name;
	string primarykey = primaryKey.ForeignKeyMemberColumns[0].Name;

	string differentiator = thiskey.Replace(primarykey, "");

	return className + differentiator;
}
public string OneToOneMemberName(TableKeySchema primaryKey)
{
	return "_" + CamelCase(OneToOneName(primaryKey));
}
public string OneToOneNameAtt(TableKeySchema primaryKey)
{
	return String.Format(" name=\"{0}\"", OneToOneName(primaryKey));
}
public string OneToOneClass(TableKeySchema primaryKey)
{
	string className = TableClass(primaryKey.ForeignKeyTable);

	return className;
}
public string OneToOneClassAtt(TableKeySchema primaryKey)
{
	string className = TableClassFull(primaryKey.ForeignKeyTable);

	return String.Format(" class=\"{0}\"", className);
}

public string JoinedSubclassName(TableKeySchema primaryKey)
{
	string className = TableClass(primaryKey.ForeignKeyTable);

	string thiskey = primaryKey.PrimaryKeyMemberColumns[0].Name;
	string primarykey = primaryKey.ForeignKeyMemberColumns[0].Name;

	string differentiator = thiskey.Replace(primarykey, "");

	return className + differentiator;
}
public string JoinedSubclassNameAtt(TableKeySchema primaryKey)
{
	string className = TableClassFull(primaryKey.ForeignKeyTable);
	return String.Format(" name=\"{0}\"", className);
}
public string JoinedSubclassTable(TableKeySchema primaryKey)
{
	return primaryKey.ForeignKeyTable.Name;
}
public string JoinedSubclassTableAtt(TableKeySchema primaryKey)
{
	return String.Format(" table=\"{0}\"", SqlIdentifier(primaryKey.ForeignKeyTable.Name));
}

public string CollectionName(TableKeySchema primaryKey)
{
//	string className = TableCollection(primaryKey.ForeignKeyTable);
	string className = primaryKey.ForeignKeyTable.Name;
	string thiskey = primaryKey.PrimaryKeyMemberColumns[0].Name;
	string primarykey = primaryKey.ForeignKeyMemberColumns[0].Name;

	string differentiator = primarykey.Replace(thiskey, "").Replace("ID","");

	return MakePlural(differentiator + className);
}
public string CollectionMemberName(TableKeySchema primaryKey)
{
	return "_" + CamelCase(CollectionName(primaryKey));
}
public string CollectionNameAtt(TableKeySchema primaryKey)
{
	string className = TableCollection(primaryKey.ForeignKeyTable);

	string thiskey = primaryKey.PrimaryKeyMemberColumns[0].Name;
	string primarykey = primaryKey.ForeignKeyMemberColumns[0].Name;

	string differentiator = primarykey.Replace(thiskey, "");

	return String.Format(" name=\"{0}\"", CollectionName(primaryKey));
}
public string CollectionType(TableKeySchema primaryKey)
{
	return "IList";
}
public string NewCollectionType(TableKeySchema primaryKey)
{
	return "new ArrayList()";
}
public string CollectionKeyColumnAtt(TableKeySchema primaryKey)
{
	ColumnSchema column = primaryKey.PrimaryKeyMemberColumns[0];
	return String.Format(" column=\"{0}\"", SqlIdentifier(column.Name));
}
public string CollectionSelfKeyColumnAtt(TableKeySchema primaryKey)
{
	ColumnSchema column = primaryKey.ForeignKeyMemberColumns[0];
	return String.Format(" column=\"{0}\"", SqlIdentifier(column.Name));
}
public string CollectionOneToManyClass(TableKeySchema primaryKey)
{
	return TableClass(primaryKey.ForeignKeyTable);
}
public string CollectionOneToManyClassAtt(TableKeySchema primaryKey)
{
	return String.Format(" class=\"{0}\"", TableClassFull(primaryKey.ForeignKeyTable));
}
public string CollectionManyToManyName(TableKeySchema primaryKey)
{
//	string className = String.Empty;

//	foreach(TableKeySchema tableKey in primaryKey.ForeignKeyTable.ForeignKeys)
//	{
//		className = TableCollection(tableKey.ForeignKeyTable);
//		if (tableKey.PrimaryKeyTable != SourceTable)
//		{
//			className = TableCollection(tableKey.PrimaryKeyTable);
//		}
//	}

//	string thiskey = primaryKey.PrimaryKeyMemberColumns[0].Name;
	string primarykey = primaryKey.ForeignKeyMemberColumns[0].Name;

//	string differentiator = primarykey.Replace(thiskey, "");
	
	string otherkey = String.Empty;
	foreach(ColumnSchema column in primaryKey.ForeignKeyTable.PrimaryKey.MemberColumns)
	{
		if (column.Name != primarykey)
		{
			otherkey = column.Name;
		}
	}
	
	string returnName = MakePlural(primarykey.Replace("ID","")+otherkey.Replace("ID",""));

	return returnName;
}
public string CollectionManyToManyMemberName(TableKeySchema primaryKey)
{
	return "_" + CamelCase(CollectionManyToManyName(primaryKey));
}
public string CollectionManyToManyNameAtt(TableKeySchema primaryKey)
{
	return String.Format(" name=\"{0}\"", CollectionManyToManyName(primaryKey));
}
public string CollectionManyToManyClass(TableKeySchema primaryKey)
{
	return TableClass(primaryKey.ForeignKeyTable);
}
public string CollectionManyToManyClassAtt(TableKeySchema primaryKey)
{
	return String.Format(" class=\"{0}\"", TableClassFull(primaryKey.PrimaryKeyTable));
}
public string CollectionTableAtt(TableKeySchema primaryKey)
{
	return String.Format(" table=\"{0}\"", SqlIdentifier(primaryKey.ForeignKeyTable.Name));
}

public string GetReaderString(ColumnSchema column)
{
	string dataType = CSharpType(column);
	if(dataType == "string")
	{
		return string.Format("NullHandler.GetString(reader[\"{0}\"])", column.Name);
	}
	else if(dataType == "bool")
	{
		return string.Format("NullHandler.GetBoolean(reader[\"{0}\"])", column.Name);
	}
	else if(dataType == "int")
	{
		return string.Format("NullHandler.GetInt32(reader[\"{0}\"])", column.Name);
	}
	else if(dataType == "DateTime")
	{
		return string.Format("NullHandler.GetDateTime(reader[\"{0}\"])", column.Name);
	}	
	else if(dataType == "byte")
	{
		return string.Format("NullHandler.GetByte(reader[\"{0}\"])", column.Name);
	}
	else if(dataType == "short")
	{
		return string.Format("NullHandler.GetShort(reader[\"{0}\"])", column.Name);
	}	
	else if(dataType == "bigint")
	{
		return string.Format("NullHandler.GetLong(reader[\"{0}\"])", column.Name);
	}
	else if(dataType == "long")
	{
		return string.Format("NullHandler.GetLong(reader[\"{0}\"])", column.Name);
	}
	else
	{
		return string.Format("NullHandler.UnKnown(reader[\"{0}\"])", column.Name);
	}
	//return string.Empty;
}

public string GetClassName(string SourceTable)
{
	if(SourceTable.IndexOf(".") > -1)	
		SourceTable = SourceTable.Substring(SourceTable.IndexOf(".") + 1);			
	
	string modifiedName = SourceTable.ToLower();
	if (modifiedName.StartsWith(RemoveTablePrefix.ToLower()))
			modifiedName = modifiedName.Substring(RemoveTablePrefix.Length);
			
	if(modifiedName.IndexOf("_") > -1)
	{	
		string [] parts = modifiedName.Split('_');
		modifiedName = string.Empty;
		for(int i = 0; i < parts.Length; i++)
		{
			if(!String.IsNullOrEmpty(parts[i]))
				modifiedName += PascalCase(parts[i]);
		}
		//SourceTable = SourceTable.Replace("_", string.Empty);
	}
	return 	modifiedName;
	//return PascalCase(SourceTable);
}

public string GetSqlDataType(ColumnSchema column)
{	
	if(column.NativeType.ToUpper().IndexOf("VARCHAR") > -1)
	{
		string fieldSize = string.Empty;
		if(column.Size == -1)
			fieldSize = "MAX";
		else
			fieldSize = column.Size.ToString();
		//return SqlCodeTemplate.GetSqlParameterStatement(column, false);
		return column.NativeType.ToUpper() + "(" + fieldSize + ")";
	}
	return column.NativeType.ToUpper();
}
public string GetParameterType(ColumnSchema column)
{
	string dbType = string.Empty;	
	if(column.NativeType.ToUpper().IndexOf("VARCHAR") > -1)
		dbType = "DbType.String";
	else if(column.NativeType.ToUpper() == "INT")
		dbType = "DbType.Int32";
	else if(column.NativeType.ToUpper() == "BIGINT")
		dbType = "DbType.Int64";
	else if(column.NativeType.ToUpper() == "BIT")
		dbType = "DbType.Boolean";
	else if(column.NativeType.ToUpper() == "DATETIME")
		dbType = "DbType.DateTime";	
	else
		dbType = "DbType.UnRecognized";
	return dbType;
}
</script>

